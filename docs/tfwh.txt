-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package tfwh
@version 0.1.0.0


-- | One man went to mow
module TFwH.OneManWentToMow

-- | song n は1人からn人まで登場する歌詞を表示する文字列を生成する
--   
--   <pre>
--   &gt;&gt;&gt; let shownl c = if c /= '\n' then [c] else "\\n\n"
--   
--   &gt;&gt;&gt; let shownls = concatMap shownl
--   
--   &gt;&gt;&gt; putStr $ shownls $ song 3
--   \n
--   One man went to mow\n
--   Went to mow a meadow\n
--   One man add his dog\n
--   Went to mow a meadow\n
--   \n
--   Two men went to mow\n
--   Went to mow a meadow\n
--   Two men, one man and his dog\n
--   Went to mow a meadow\n
--   \n
--   Three men went to mow\n
--   Went to mow a meadow\n
--   Three men, two men, one man and his dog\n
--   Went to mow a meadow\n
--   </pre>
song :: Int -> String


-- | 6桁以下の整数を英語読みに変換
module TFwH.NumbersIntoWords

-- | 数を英単語に変換する
--   
--   <pre>
--   &gt;&gt;&gt; convert 308000
--   "three hundreds and eight thousand"
--   
--   &gt;&gt;&gt; convert 369027
--   "three hundreds and sixty-nine thousand and twenty-seven"
--   
--   &gt;&gt;&gt; convert 369401
--   "three hundreds and sixty-nine thousand four hundreds and one"
--   </pre>
convert :: Int -> String


-- | 頻出単語
module TFwH.CommonWords

-- | テキストの型
type Text = [Char]

-- | 単語の型
type Word = [Char]

-- | commonWords n はテキストから頻出単語の出現回数の上位 n 個の単語を出現回数とともに表示するための文字列を生成する．
--   
--   <pre>
--   commonWords n = unlines      -- 連結する
--                 . map showRun  -- 単語と出現回数をを表示する文字列を生成する
--                 . take n       -- 上位 n 個を取り出す
--                 . sortRuns     -- 出現回数順でソートする
--                 . countRuns    -- 出現回数を数えて単語と出現回数を対にする
--                 . sortWords    -- 単語をソートする
--                 . words        -- テキストを単語に分解
--                 . map toLower  -- テキストの文字をすべて小文字にする
--   </pre>
commonWords :: Int -> Text -> String

-- | 単語をソートする
sortWords :: [Word] -> [Word]

-- | 出現回数を数えて単語と出現回数を対にする
countRuns :: [Word] -> [(Int, Word)]

-- | 出現回数順でソートする
sortRuns :: [(Int, Word)] -> [(Int, Word)]

-- | 単語と出現回数をを表示する文字列を生成する
showRun :: (Int, Word) -> String

module TFwH.Chap01.ExE
type Fun = Int -> Int

-- | <pre>
--   (x + y) + z == (x :: Int) + (y + z)
--   </pre>
--   
--   <pre>
--   0 + y == (y :: Int)
--   </pre>
--   
--   <pre>
--   x + 0 == (x :: Int)
--   </pre>
--   
--   <pre>
--   (xs ++ ys) ++ zs == (xs :: String) ++ (ys ++ zs)
--   </pre>
--   
--   <pre>
--   [] ++ ys == (ys :: String)
--   </pre>
--   
--   <pre>
--   xs ++ [] == (xs :: String)
--   </pre>
--   
--   <pre>
--   (((f::Fun) . (g::Fun)) . (h::Fun)) (x::Int) == (f . (g . h)) x
--   </pre>
--   
--   <pre>
--   (id . g) x == (g :: Fun) (x :: Int)
--   </pre>
--   
--   <pre>
--   (f . id) x == (f :: Fun) (x :: Int)
--   </pre>
instance GHC.Show.Show TFwH.Chap01.ExE.Fun

module TFwH.Chap01.ExD
type Text = String
type Word = String
words' :: Text -> [Word]

-- | <pre>
--   &gt;&gt;&gt; let sample = "To be or not to be"
--   
--   &gt;&gt;&gt; words' sample
--   ["to","be","or","not","to","be"]
--   
--   &gt;&gt;&gt; words'' sample
--   ["to","be","or","not","to","be"]
--   </pre>
words'' :: Text -> [Word]


-- | 練習問題 C
--   
--   $desc
module TFwH.Chap01.ExC

module TFwH.Chap01.ExB

-- | <pre>
--   &gt;&gt;&gt; import Data.Typeable
--   
--   &gt;&gt;&gt; typeOf $ sin theta^2
--   Double
--   
--   &gt;&gt;&gt; typeOf $ (sin theta)^2
--   Double
--   </pre>
theta :: Double


-- | 第1章 練習問題 A
module TFwH.Chap01.ExA

-- | 指定した整数の2倍
--   
--   <pre>
--   double x = 2 * x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map double [1, 4, 4, 3]
--   [2,8,8,6]
--   
--   &gt;&gt;&gt; map (double . double) [1, 4, 4, 3]
--   [4,16,16,12]
--   
--   &gt;&gt;&gt; map double []
--   []
--   </pre>
double :: Integer -> Integer

-- | 整数のリストの総和
--   
--   <pre>
--   sum [] = 0
--   sum (x:xs) = x + sum xs
--   </pre>
--   
--   <pre>
--   法則: sum . map double = double . sum
--   </pre>
--   
--   <pre>
--   (sum . map double) (xs :: [Integer]) == (double . sum) xs
--   </pre>
--   
--   <pre>
--   [] の場合：
--     sum (map double [])
--   =   { mapの定義 }
--     sum []
--   =   { sumの定義 }
--     0
--   =   { 算術 }
--     2 * 0
--   =   { doubleの定義 }
--     double 0
--   =   { sumの定義 }
--     double (sum [])
--   
--   x:xs の場合：
--     sum (map double (x:xs))
--   =   { mapの定義 }
--     sum (double x : map double (x:xs))
--   =   { sumの定義 }
--     double x + sum (map double xs)
--   =   { 帰納法の仮定 }
--     double x + double (sum xs)
--   =   { doubleの定義 }
--     2 * x + 2 * sum xs
--   =   { 分配則 }
--     2 * (x + sum xs)
--   =   { sumの定義 }
--     2 * (sum (x:xs))
--   =   { doubleの定義 }
--     double (sum (x:xs))
--   </pre>
sum :: [Integer] -> Integer

-- | リストのリストを連結
--   
--   <pre>
--   concat [] = []
--   concat (xs:xss) = xs ++ concat xss
--   </pre>
--   
--   <pre>
--   法則: sum . map sum = sum . concat
--   </pre>
--   
--   <pre>
--   [] の場合：
--     sum (map sum [])
--   =   { mapの定義 }
--     sum []
--   =   { concatの定義 }
--     sum (concat [])
--   
--   xs:xss の場合
--     sum (map sum (xs:xss))
--   =   { mapの定義 }
--     sum (sum xs : map sum xss)
--   =   { sumの定義 }
--     sum xs + sum (map sum xss)
--   =   { 帰納法の仮定 }
--     sum xs + sum (concat xss)
--   =   { sum xs + sum ys = sum (xs ++ ys) だから (1)}
--     sum ( xs ++ concat xss)
--   =   { concatの定義 }
--     sum ( concat (xs:xss))
--   </pre>
--   
--   <pre>
--   主張(1) xs 上の帰納法
--   
--   []の場合：
--     sum [] + sum ys
--   =  { sumの定義 }
--     0 + sum ys
--   =  { 0は(+)の単位元 }
--     sum ys
--   =  { []は(++)の単位元 }
--     sum ([] ++ ys)
--   
--   x:xsの場合：
--     sum (x:xs) + sum ys
--   =   { sumの定義 }
--     (x + sum xs) + sum ys
--   =   { (+)の結合性 }
--     x + (sum xs + sum ys)
--   =   { 帰納法の仮定 }
--     x + sum (xs ++ ys)
--   =   { sum の定義 }
--     sum (x : (xs ++ ys))
--   =   { (++)の定義 }
--     sum ((x:xs) ++ ys)
--   </pre>
concat :: [[a]] -> [a]

-- | 整列
--   
--   <pre>
--   sort [] = []
--   sort (x:xs) = insert x (sort xs)
--   </pre>
--   
--   <pre>
--   法則: sum . sort = sum
--   </pre>
--   
--   <pre>
--   [] の場合：
--     sum (sort [])
--   =   { sortの定義 }
--     sum []
--   
--   (x:xs)
--     sum (sort (x:xs))
--   =   { sortの仕様 }
--     sum (insert x (sort xs))
--   =   { sum (insert y ys) = y + sum ys だから (2)}
--     x + sum (sort xs)
--   =   { 帰納法の仮定 }
--     x + sum xs
--   =   { sumの定義 }
--     sum (x:xs)
--   </pre>
sort :: Ord a => [a] -> [a]

-- | ソート済みのリストに新しい要素を挿入
--   
--   <pre>
--   insert x [] = [x]
--   insert x (y:ys) = if x &lt;= y then x : y : ys
--                     else y : insert x ys
--   </pre>
--   
--   <pre>
--   主張(2) ys 上の帰納法
--   
--   []の場合：
--     sum (insert x [])
--   =   { insertの定義 }
--     sum [x]
--   =   { sumの定義 }
--     x + sum []
--   
--   y:ysの場合： x &lt;= y ならば
--     sum (insert x (y:ys))
--   =   { insertの定義 }
--     sum (x:(y:ys))
--   =   { sumの定義 }
--     x + sum (y:ys)
--   
--   y:ysの場合： x &gt; y ならば
--     sum (insert x (y:ys))
--   =   { insertの定義 }
--     sum (y : insert x ys)
--   =   { sumの定義 }
--     y + sum (insert x ys)
--   =   { 帰納法の仮定 }
--     y + (x + sum ys)
--   =   { (+)の結合性 }
--     (y + x) + sum ys
--   =   { (+)の可換性 }
--     (x + y) + sum ys
--   =   { (+)の結合性 }
--     x + (y + sum ys)
--   =   { sumの定義 }
--     x + sum (y:ys)
--   </pre>
insert :: Ord a => a -> [a] -> [a]


-- | TFwH 第1章 関数プログラミングとは何か
module TFwH.Chap01

-- | テキストの型
type Text = [Char]

-- | 単語の型
type Word = [Char]

-- | commonWords n はテキストから頻出単語の出現回数の上位 n 個の単語を出現回数とともに表示するための文字列を生成する．
--   
--   <pre>
--   commonWords n = concat       -- 連結する
--                 . map showRun  -- 単語と出現回数をを表示する文字列を生成する
--                 . take n       -- 上位 n 個を取り出す
--                 . sortRuns     -- 出現回数順でソートする
--                 . countRuns    -- 出現回数を数えて単語と出現回数を対にする
--                 . sortWords    -- 単語をソートする
--                 . words        -- テキストを単語に分解
--                 . map toLower  -- テキストの文字をすべて小文字にする
--   </pre>
commonWords :: Int -> Text -> String

-- | 未定義
sortWords :: [Word] -> [Word]

-- | 未定義
countRuns :: [Word] -> [(Int, Word)]

-- | 未定義
sortRuns :: [(Int, Word)] -> [(Int, Word)]

-- | 未定義
showRun :: (Int, Word) -> String

-- | 6桁以下の数を英単語に変換する
--   
--   <pre>
--   &gt;&gt;&gt; convert 308000
--   "three hundreds and eight thousand"
--   
--   &gt;&gt;&gt; convert 369027
--   "three hundreds and sixty-nine thousand and twenty-seven"
--   
--   &gt;&gt;&gt; convert 369401
--   "three hundreds and sixty-nine thousand four hundreds and one"
--   </pre>
convert :: Int -> String

-- | 1桁の数
units :: [String]

-- | 10台の数
teens :: [String]

-- | 10の倍数
tens :: [String]

-- | 1桁の数の変換
convert1 :: Int -> String

-- | 2桁の数の桁分解
digits2 :: Int -> (Int, Int)

-- | 2桁の数の変換
convert2 :: Int -> String

-- | 2つの桁を合成
combine2 :: (Int, Int) -> String

-- | 3桁の数の変換
convert3 :: Int -> String

-- | 6桁の数の変換
convert6 :: Int -> String

-- | 接続詞
link :: Int -> String


-- | アナグラム一覧
module TFwH.Anagrams

-- | 単語の型
type Word = String

-- | ラベルの型
type Label = String

-- | anagrams n はアルファベット順の英単語リストから n 文字の単語だけを選別し,
--   同じアナグラムになる単語をまとめた結果を表示するための文字列を生成する． この文字列を表示するとn文字の単語のアナグラムの一覧となる．
--   
--   <pre>
--   anagrams n = unlines        -- 連結する
--              . map showEntry  -- エントリーを文字列に変換する
--              . groupByLabel   -- 同一ラベルのラベル付き単語をグループ化してエントリー作成する
--              . sortLabels     -- ラベル付き単語をラベルの辞書順でソートする
--              . map addLabel   -- 単語にラベルを追加する
--              . getWords n     -- n 文字の単語だけ取り出す
--   </pre>
anagrams :: Int -> [Word] -> String

-- | n 文字の単語だけを濾過
getWords :: Int -> [Word] -> [Word]

-- | 単語にラベルを追加
addLabel :: Word -> (Label, Word)

-- | ラベル付き単語をラベルの辞書順でソート
sortLabels :: [(Label, Word)] -> [(Label, Word)]

-- | 同一ラベルの付いた単語をグループ化してエントリー作成
groupByLabel :: [(Label, Word)] -> [(Label, [Word])]

-- | エントリーを文字列に変換
showEntry :: (Label, [Word]) -> String
