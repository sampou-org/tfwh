-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package tfwh
@version 0.2.7.0


-- | One man went to mow
module TFwH.OneManWentToMow

-- | song n は1人からn人まで登場する歌詞を表示する文字列を生成する
--   
--   <pre>
--   &gt;&gt;&gt; let shownl c = if c /= '\n' then [c] else "\\n\n"
--   
--   &gt;&gt;&gt; let shownls = concatMap shownl
--   
--   &gt;&gt;&gt; putStr $ shownls $ song 3
--   \n
--   One man went to mow\n
--   Went to mow a meadow\n
--   One man add his dog\n
--   Went to mow a meadow\n
--   \n
--   Two men went to mow\n
--   Went to mow a meadow\n
--   Two men, one man and his dog\n
--   Went to mow a meadow\n
--   \n
--   Three men went to mow\n
--   Went to mow a meadow\n
--   Three men, two men, one man and his dog\n
--   Went to mow a meadow\n
--   </pre>
song :: Int -> String


-- | 6桁以下の整数を英語読みに変換
module TFwH.NumbersIntoWords

-- | 数を英単語に変換する
--   
--   <pre>
--   &gt;&gt;&gt; convert 308000
--   "three hundreds and eight thousand"
--   
--   &gt;&gt;&gt; convert 369027
--   "three hundreds and sixty-nine thousand and twenty-seven"
--   
--   &gt;&gt;&gt; convert 369401
--   "three hundreds and sixty-nine thousand four hundreds and one"
--   </pre>
convert :: Int -> String


-- | 頻出単語
module TFwH.CommonWords

-- | テキストの型
type Text = [Char]

-- | 単語の型
type Word = [Char]

-- | commonWords n はテキストから頻出単語の出現回数の上位 n 個の単語を出現回数とともに表示するための文字列を生成する．
--   
--   <pre>
--   commonWords n = unlines      -- 連結する
--                 . map showRun  -- 単語と出現回数をを表示する文字列を生成する
--                 . take n       -- 上位 n 個を取り出す
--                 . sortRuns     -- 出現回数順でソートする
--                 . countRuns    -- 出現回数を数えて単語と出現回数を対にする
--                 . sortWords    -- 単語をソートする
--                 . words        -- テキストを単語に分解
--                 . map toLower  -- テキストの文字をすべて小文字にする
--   </pre>
commonWords :: Int -> Text -> String

-- | 単語をソートする
sortWords :: [Word] -> [Word]

-- | 出現回数を数えて単語と出現回数を対にする
countRuns :: [Word] -> [(Int, Word)]

-- | 出現回数順でソートする
sortRuns :: [(Int, Word)] -> [(Int, Word)]

-- | 単語と出現回数をを表示する文字列を生成する
showRun :: (Int, Word) -> String


-- | <h1>第2章 練習問題 G</h1>
--   
--   <ul>
--   <li><tt>showDate :: Date -&gt; String</tt> を定義せよ<pre>type Year = Int
--   type Month = Int type Day = Int type Date = (Day, Month, Year)
--   showDate :: Date -&gt; String showDate (d, m, y) = show d ++ suffix d
--   ++ " " ++ months !! (m - 1) ++ ", " ++ show y months = [
--   <a>January</a>, <a>Feburary</a>, <a>March</a>, <a>April</a> ,
--   <a>May</a>, <a>June</a>, <a>July</a>, <a>August</a> ,
--   <a>September</a>, <a>October</a>, <a>November</a>, <a>December</a> ]
--   </pre></li>
--   </ul>
module TFwH.Chap02.ExG
type Year = Int
type Month = Int
type Day = Int
type Date = (Day, Month, Year)

-- | 日付を表示文字列に変換
--   
--   <pre>
--   &gt;&gt;&gt; showDate (10, 12, 2013)
--   "10th December, 2013"
--   
--   &gt;&gt;&gt; showDate (21, 11, 2020)
--   "21st November, 2020"
--   </pre>
showDate :: Date -> String

-- | 日付序数詞の接尾辞
suffix :: Day -> String

-- | 月の名
months :: [[Char]]


-- | <h1>第2章 練習問題 F</h1>
--   
--   <ul>
--   <li>以下は x の n 乗を求める関数で，この関数では exp x n を求めるのに n-1 回の乗算が必要です．<pre>exp ::
--   Integer -&gt; Integer -&gt; Integer exp x n | n == 0 = 1 | n == 1 = x
--   | otherwise = x * exp x (n - 1) </pre></li>
--   </ul>
--   
--   <ul>
--   <li>尻高君の方法は以下のとおりで，乗算は高々 2p 回です．<pre>exp :: Integer -&gt; Integer
--   -&gt; Integer exp x n | n == 0 = 1 | n == 1 = x | even n = exp (x * x)
--   m | odd n = x * exp (x * x) m </pre></li>
--   <li>関数呼び出しトレース</li>
--   </ul>
--   
--   以下はオマケ(説明はありません)．
module TFwH.Chap02.ExF

-- | O(n) 回の乗算を必要とする expG を生成する汎関数
gexpG :: (Integer -> Integer -> Integer) -> (Integer -> Integer -> Integer)

-- | O(n) 回の乗算を必要とする exp
--   
--   <pre>
--   &gt;&gt;&gt; expG 2 13
--   8192
--   </pre>
expG :: Integer -> Integer -> Integer

-- | O(n) 回の乗算を必要とする exp のトレース版
--   
--   <pre>
--   &gt;&gt;&gt; expG' 2 13
--   exp 2 13
--   exp 2 12
--   exp 2 11
--   exp 2 10
--   exp 2 9
--   exp 2 8
--   exp 2 7
--   exp 2 6
--   exp 2 5
--   exp 2 4
--   exp 2 3
--   exp 2 2
--   exp 2 1
--   8192
--   </pre>
expG' :: Integer -> Integer -> Integer

-- | O(log n) 回の乗算を必要とする expS を生成する汎関数
gexpS :: (Integer -> Integer -> Integer) -> (Integer -> Integer -> Integer)

-- | O(log n) 回の乗算を必要とする exp
--   
--   <pre>
--   &gt;&gt;&gt; expS 2 13
--   8192
--   </pre>
expS :: Integer -> Integer -> Integer

-- | O(log n) 回の乗算を必要とする exp のトレース版
--   
--   <pre>
--   &gt;&gt;&gt; expS' 2 13
--   exp 2 13
--   exp 4 6
--   exp 16 3
--   exp 256 1
--   8192
--   </pre>
expS' :: Integer -> Integer -> Integer

-- | 関数呼び出しの簡単なトレースを生成
traceOfCall :: (Show a, Show b) => String -> (a -> b -> c) -> a -> b -> c

-- | トレースを追加する関数
tracing :: (Show a, Show b) => String -> ((a -> b -> c) -> a -> b -> c) -> a -> b -> c

-- | 機能 f を g に追加するした汎関数の不動点を求める
gfun :: ((a -> b) -> (c -> d)) -> ((c -> d) -> (a -> b)) -> (c -> d)


-- | <h1>第2章 練習問題 E</h1>
module TFwH.Chap02.ExE

-- | <pre>
--   first :: (a -&gt; Bool) -&gt; [a] -&gt; a
--   first p = head . filter p
--   </pre>
--   
--   <pre>
--   first :: (a -&gt; Bool) -&gt; [a] -&gt; a
--   first p xs | null xs   = error "Empty list"
--              | p x       = x
--              | otherwise = firstB p (tail xs)
--              where
--                x = head xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let firstS p = head . filter p  -- Susan版
--   
--   &gt;&gt;&gt; first isSquare nums == firstS isSquare nums
--   True
--   </pre>
first :: (a -> Bool) -> [a] -> a

-- | Susan の first' :: (b -&gt; Bool) -&gt; (a -&gt; b) -&gt; [a] -&gt; b
--   
--   <pre>
--   first' :: (b -&gt; Bool) -&gt; (a -&gt; b) -&gt; [a] -&gt; b
--   first' p f = head . filter p . map f
--   </pre>
--   
--   Beaver の first'
--   
--   <pre>
--   first'  :: (b -&gt; Bool) -&gt; (a -&gt; b) -&gt; [a] -&gt; b
--   first' p f xs | null xs = error "Empty list"
--                 | p x     = x
--                 | otherwise = first' p f (tail xs)
--                 where
--                   x = f (head xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let first'S p f = head . filter p . map f
--   
--   &gt;&gt;&gt; first' isSquare (subtract 1 . (2*)) nums == first'S isSquare (subtract 1 . (2*)) nums
--   True
--   </pre>
first' :: (b -> Bool) -> (a -> b) -> [a] -> b

-- | より好ましい betterFistB (Beaver 版)
--   
--   <pre>
--   betterFirstB :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a
--   betterFirstB p xs
--     | null xs   = Nothing
--     | p x       = Just x
--     | otherwise = betterFirstBeaver p (tail xs)
--     where
--       x = head xs
--   </pre>
betterFirstB :: (a -> Bool) -> [a] -> Maybe a

-- | より好ましい betterFistS (Susan 版)
--   
--   <pre>
--   betterFirstS :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a
--   betterFirstS p = maybe Nothing (Just . fst) . uncons . filter p
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum nums'
--   499999500000
--   
--   &gt;&gt;&gt; betterFirstB isSquare nums' == betterFirstS isSquare nums
--   True
--   </pre>
betterFirstS :: (a -> Bool) -> [a] -> Maybe a

-- | テスト用データ 1
--   
--   <pre>
--   nums :: [Int]
--   nums =  [999999, 999998 .. 0]
--   </pre>
nums :: [Int]

-- | テスト用データ 2 nums と同値ですが，先頭の要素を取り出した時点で長さ1000000のリストができています．
nums' :: [Int]

-- | お試し用述語
--   
--   <pre>
--   isSquare :: Int -&gt; Bool
--   isSquare = (==) <a>*</a> (^2) . round . sqrt . fromIntegral 
--   </pre>
isSquare :: Int -> Bool

-- | 多相関数 polyN :: Maybe a -&gt; Maybe a を生成する関数
poly :: Int -> (Maybe a -> Maybe a)

-- | 型クラスShowのインスタンスである型の値を表示 IO ()
prna :: Show a => a -> IO String

-- | Maybe a の値を表示 IO ()
prn :: Show a => Maybe a -> IO ()

-- | テスト用引数
samples :: [Maybe ()]

-- | 表示テスト
--   
--   <pre>
--   &gt;&gt;&gt; test
--   Nothing
--   Nothing
--   Nothing
--   ⊥
--   -----
--   Nothing
--   Just ()
--   Just ⊥
--   ⊥
--   -----
--   Nothing
--   Just ⊥
--   Just ⊥
--   ⊥
--   -----
--   Nothing
--   ⊥
--   ⊥
--   ⊥
--   -----
--   Just ⊥
--   Nothing
--   Nothing
--   ⊥
--   -----
--   Just ⊥
--   Just ()
--   Just ⊥
--   ⊥
--   -----
--   Just ⊥
--   Just ⊥
--   Just ⊥
--   ⊥
--   -----
--   Just ⊥
--   ⊥
--   ⊥
--   ⊥
--   -----
--   ⊥
--   Nothing
--   Nothing
--   ⊥
--   -----
--   ⊥
--   Just ()
--   Just ⊥
--   ⊥
--   -----
--   ⊥
--   Just ⊥
--   Just ⊥
--   ⊥
--   -----
--   ⊥
--   ⊥
--   ⊥
--   ⊥
--   -----
--   Nothing
--   Nothing
--   Nothing
--   Nothing
--   -----
--   Just ⊥
--   Just ⊥
--   Just ⊥
--   Just ⊥
--   -----
--   Just ⊥
--   Just ()
--   Just ⊥
--   Just ⊥
--   </pre>
test :: IO ()


-- | <h1>第2章 練習問題 D</h1>
module TFwH.Chap02.ExD

-- | Susan版 first は
--   
--   <pre>
--   first :: (a -&gt; Bool) -&gt; [a] -&gt; a
--   first p = head . filter p
--   </pre>
--   
--   Beaver版 first は
--   
--   <pre>
--   first :: (a -&gt; Bool) -&gt; [a] -&gt; a
--   first p xs | null xs   = error "Empty list"
--              | p x       = x
--              | otherwise = firstB p (tail xs)
--              where
--                x = head xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let firstS p = head . filter p  -- Susan版
--   
--   &gt;&gt;&gt; first isSquare nums == firstS isSquare nums
--   True
--   </pre>
first :: (a -> Bool) -> [a] -> a

-- | Susan の first' :: (b -&gt; Bool) -&gt; (a -&gt; b) -&gt; [a] -&gt; b
--   
--   <pre>
--   first' :: (b -&gt; Bool) -&gt; (a -&gt; b) -&gt; [a] -&gt; b
--   first' p f = head . filter p . map f
--   </pre>
--   
--   Beaver の first'
--   
--   <pre>
--   first'  :: (b -&gt; Bool) -&gt; (a -&gt; b) -&gt; [a] -&gt; b
--   first' p f xs | null xs = error "Empty list"
--                 | p x     = x
--                 | otherwise = first' p f (tail xs)
--                 where
--                   x = f (head xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let first'S p f = head . filter p . map f
--   
--   &gt;&gt;&gt; first' isSquare (subtract 1 . (2*)) nums == first'S isSquare (subtract 1 . (2*)) nums
--   True
--   </pre>
first' :: (b -> Bool) -> (a -> b) -> [a] -> b


-- | <h1>第2章 練習問題 C</h1>
--   
--   <ul>
--   <li>関数 toLower :: Char -&gt; Char は英字を小文字に変換する．
--   標準ライブラリの英字を大文字に変換する関数はどういう名前だと思うか．<ul><li>toUpper</li></ul></li>
--   </ul>
--   
--   <ul>
--   <li>関数 words :: String -&gt; [Word] は前章で使った関数である． プレリュード関数 unwords ::
--   [Word] -&gt; String は何をする関数だと思うか．
--   ヒント：以下の等式の一方だけが成り立つとすればどちらか．<pre>words . unwords = id unwords . words
--   = id </pre><ul><li>words . unwords = id</li></ul></li>
--   <li>関数 head :: [a] -&gt; a は空ではないリストの先頭を返す． 関数 tail :: [a] -&gt; [a]
--   は空ではないリストから先頭要素を取り除いた残りのリストすなわち末尾部分を返す． あるリストの先頭が x で末尾部が xs
--   だとすると，もとのリストを再構成するにはどうすればよいか．<ul><li>[x] ++ xs</li></ul></li>
--   </ul>
module TFwH.Chap02.ExC
type Word = String

-- | <pre>
--   capitaliseTitle = unwords . map capitalize . words
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; modernise "The morphology of prex -- an essay in meta-algorithmics"
--   "The Morphology Of Prex -- An Essay In Meta-Algorithmics"
--   </pre>
modernise :: String -> String

-- | 実装は本文の解答では
--   
--   <pre>
--   capitalise xs = [toUpper (head xs)] ++ tail xs
--   </pre>
--   
--   となっているが，これだと
--   
--   <pre>
--   capitalise "meta-algorithmics" = "Meta-Algorithmics"
--   </pre>
--   
--   にはならない．この仕様を満すには以下のような実装が必要である．
--   
--   <pre>
--   capitalise cs = case break ('-'==) cs of
--     (x:xs,"")   -&gt; toUpper x : xs
--     (x:xs,y:ys) -&gt; toUpper x : (xs ++ y : capitalise ys)
--     _           -&gt; cs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; capitalise "the"
--   "The"
--   
--   &gt;&gt;&gt; capitalise "meta-algorithmics"
--   "Meta-Algorithmics"
--   </pre>
capitalise :: Word -> Word


-- | 第2章 練習問題 B
--   
--   GHCi のプロンプトで以下のコマンドを順に試してみよう．
--   
--   <pre>
--   :type [0, 1)
--   :type double -3
--   :type double (-3)
--   :type double double 0
--   :type if 1 == 0 then 2 == 1
--   :type "++" == "+" ++ "+"
--   :type [(+), (-)]
--   :type [[], [[]], [[[]]]]
--   :type concat ["tea", "for", '2']
--   :type concat ["tea", "for", "2"]
--   </pre>
module TFwH.Chap02.ExB

-- | <pre>
--   double = (2 *)
--   </pre>
double :: Int -> Int


-- | 第2章 練習問題 A
--   
--   問：2足す2の半分は2かそれとも3か 答：そのとおり
module TFwH.Chap02.ExA

-- | <pre>
--   problem' = 2 + (2 <a>div</a> 2)
--   </pre>
problem' :: Int

-- | <pre>
--   problem'' = (2 + 2) <a>div</a> 2
--   </pre>
problem'' :: Int

-- | <pre>
--   answer' = 3
--   </pre>
answer' :: Int

-- | <pre>
--   answer'' = 2
--   </pre>
answer'' :: Int

-- | <pre>
--   answer = (problem'  == answer' || problem'  == answer'' )
--         &amp;&amp; (problem'' == answer' || problem'' == answer'' )
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; answer
--   True
--   </pre>
answer :: Bool


-- | TFwH 第2章 式,型,値
module TFwH.Chap02

-- | ユーザ定義演算子
(+++) :: Int -> Int -> Int

-- | 整数の2乗
sqr :: Integer -> Integer

-- | 無限大
infinity :: Integer

-- | 常に3になる定数関数
three :: Integer -> Integer

-- | 階乗関数
factorial :: Integer -> Integer

-- | 下請け関数
fact :: (Integer, Integer) -> Integer

-- | 無限ループする関数
to :: Bool -> Bool
type Pin = Int

-- | Person(例)
data Person
Person :: Pin -> Person
[pin] :: Person -> Pin
samePerson :: Person -> Person -> Bool

-- | 頻出単語
cwords :: Int -> FilePath -> FilePath -> IO ()

-- | 2次方程式の解
roots :: (Float, Float, Float) -> (Float, Float)
instance GHC.Classes.Eq TFwH.Chap02.Person

module TFwH.Chap01.ExG
song :: Int -> String
verse :: Int -> String
line1 :: Int -> String
line2 :: Int -> String
line3 :: Int -> String
line4 :: Int -> String
count :: Int -> String
numbers :: [String]
numbs :: [String]

module TFwH.Chap01.ExF
type Word = String
type Label = String
type Labeled = (,) Label
type Anagram = (Label, [Word])

-- | anagrams n はアルファベット順の英単語リストを取り，n文字の単語だけをとりだし，文字列を生成する．
--   結果の文字列を表示するとn文字の単語のアナグラムの一覧となるものとする．
--   
--   <pre>
--   anagrams n = unlines           -- 一覧表示
--              . map showAnagram   -- アナグラムを表示
--              . groupByLabel      -- 同一ラベルの単語をグループ化
--              . sortByLabel       -- アナグラムラベルでソート
--              . map addLabel      -- アナグラムラベルを単語に追加
--              . selectByLength n  -- n文字の単語だけ選択
--   </pre>
anagrams :: Int -> [Word] -> String

-- | 未定義
selectByLength :: Int -> [Word] -> [Word]

-- | 未定義
addLabel :: Word -> Labeled Word

-- | 未定義
sortByLabel :: [Labeled Word] -> [Labeled Word]

-- | 未定義
groupByLabel :: [Labeled Word] -> [Anagram]

-- | 未定義
showAnagram :: Anagram -> String

module TFwH.Chap01.ExE
type Fun = Int -> Int

-- | <pre>
--   (x + y) + z == (x :: Int) + (y + z)
--   </pre>
--   
--   <pre>
--   0 + y == (y :: Int)
--   </pre>
--   
--   <pre>
--   x + 0 == (x :: Int)
--   </pre>
--   
--   <pre>
--   (xs ++ ys) ++ zs == (xs :: String) ++ (ys ++ zs)
--   </pre>
--   
--   <pre>
--   [] ++ ys == (ys :: String)
--   </pre>
--   
--   <pre>
--   xs ++ [] == (xs :: String)
--   </pre>
--   
--   <pre>
--   (((f::Fun) . (g::Fun)) . (h::Fun)) (x::Int) == (f . (g . h)) x
--   </pre>
--   
--   <pre>
--   (id . g) x == (g :: Fun) (x :: Int)
--   </pre>
--   
--   <pre>
--   (f . id) x == (f :: Fun) (x :: Int)
--   </pre>
instance GHC.Show.Show TFwH.Chap01.ExE.Fun

module TFwH.Chap01.ExD
type Text = String
type Word = String
words' :: Text -> [Word]

-- | <pre>
--   &gt;&gt;&gt; let sample = "To be or not to be"
--   
--   &gt;&gt;&gt; words' sample
--   ["to","be","or","not","to","be"]
--   
--   &gt;&gt;&gt; words'' sample
--   ["to","be","or","not","to","be"]
--   </pre>
words'' :: Text -> [Word]


-- | 練習問題 C
--   
--   <pre>
--   &gt;&gt;&gt; :type 'H'
--   'H' :: Char
--   
--   &gt;&gt;&gt; :type "H"
--   "H" :: [Char]
--   
--   &gt;&gt;&gt; :type 2001
--   2001 :: Num t =&gt; t
--   
--   &gt;&gt;&gt; :type "2001"
--   "2001" :: [Char]
--   
--   &gt;&gt;&gt; [1, 2, 3] ++ [3, 2, 1]
--   [1,2,3,3,2,1]
--   
--   &gt;&gt;&gt; "Hello" ++ " World!"
--   "Hello World!"
--   
--   &gt;&gt;&gt; [1, 2, 3] ++ []
--   [1,2,3]
--   
--   &gt;&gt;&gt; "Hello" ++ " " ++ "World!"
--   "Hello World!"
--   </pre>
module TFwH.Chap01.ExC

module TFwH.Chap01.ExB

-- | <pre>
--   &gt;&gt;&gt; import Data.Typeable
--   
--   &gt;&gt;&gt; typeOf $ sin theta^2
--   Double
--   
--   &gt;&gt;&gt; typeOf $ (sin theta)^2
--   Double
--   </pre>
theta :: Double


-- | 第1章 練習問題 A
module TFwH.Chap01.ExA

-- | 指定した整数の2倍
--   
--   <pre>
--   double x = 2 * x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map double [1, 4, 4, 3]
--   [2,8,8,6]
--   
--   &gt;&gt;&gt; map (double . double) [1, 4, 4, 3]
--   [4,16,16,12]
--   
--   &gt;&gt;&gt; map double []
--   []
--   </pre>
double :: Integer -> Integer

-- | 整数のリストの総和
--   
--   <pre>
--   sum [] = 0
--   sum (x:xs) = x + sum xs
--   </pre>
--   
--   <pre>
--   法則: sum . map double = double . sum
--   </pre>
--   
--   <pre>
--   (sum . map double) (xs :: [Integer]) == (double . sum) xs
--   </pre>
--   
--   <pre>
--   [] の場合：
--     sum (map double [])
--   =   { mapの定義 }
--     sum []
--   =   { sumの定義 }
--     0
--   =   { 算術 }
--     2 * 0
--   =   { doubleの定義 }
--     double 0
--   =   { sumの定義 }
--     double (sum [])
--   
--   x:xs の場合：
--     sum (map double (x:xs))
--   =   { mapの定義 }
--     sum (double x : map double (x:xs))
--   =   { sumの定義 }
--     double x + sum (map double xs)
--   =   { 帰納法の仮定 }
--     double x + double (sum xs)
--   =   { doubleの定義 }
--     2 * x + 2 * sum xs
--   =   { 分配則 }
--     2 * (x + sum xs)
--   =   { sumの定義 }
--     2 * (sum (x:xs))
--   =   { doubleの定義 }
--     double (sum (x:xs))
--   </pre>
sum :: [Integer] -> Integer

-- | リストのリストを連結
--   
--   <pre>
--   concat [] = []
--   concat (xs:xss) = xs ++ concat xss
--   </pre>
--   
--   <pre>
--   法則: sum . map sum = sum . concat
--   </pre>
--   
--   <pre>
--   [] の場合：
--     sum (map sum [])
--   =   { mapの定義 }
--     sum []
--   =   { concatの定義 }
--     sum (concat [])
--   
--   xs:xss の場合
--     sum (map sum (xs:xss))
--   =   { mapの定義 }
--     sum (sum xs : map sum xss)
--   =   { sumの定義 }
--     sum xs + sum (map sum xss)
--   =   { 帰納法の仮定 }
--     sum xs + sum (concat xss)
--   =   { sum xs + sum ys = sum (xs ++ ys) だから (1)}
--     sum ( xs ++ concat xss)
--   =   { concatの定義 }
--     sum ( concat (xs:xss))
--   </pre>
--   
--   <pre>
--   主張(1) xs 上の帰納法
--   
--   []の場合：
--     sum [] + sum ys
--   =  { sumの定義 }
--     0 + sum ys
--   =  { 0は(+)の単位元 }
--     sum ys
--   =  { []は(++)の単位元 }
--     sum ([] ++ ys)
--   
--   x:xsの場合：
--     sum (x:xs) + sum ys
--   =   { sumの定義 }
--     (x + sum xs) + sum ys
--   =   { (+)の結合性 }
--     x + (sum xs + sum ys)
--   =   { 帰納法の仮定 }
--     x + sum (xs ++ ys)
--   =   { sum の定義 }
--     sum (x : (xs ++ ys))
--   =   { (++)の定義 }
--     sum ((x:xs) ++ ys)
--   </pre>
concat :: [[a]] -> [a]

-- | 整列
--   
--   <pre>
--   sort [] = []
--   sort (x:xs) = insert x (sort xs)
--   </pre>
--   
--   <pre>
--   法則: sum . sort = sum
--   </pre>
--   
--   <pre>
--   [] の場合：
--     sum (sort [])
--   =   { sortの定義 }
--     sum []
--   
--   (x:xs)
--     sum (sort (x:xs))
--   =   { sortの仕様 }
--     sum (insert x (sort xs))
--   =   { sum (insert y ys) = y + sum ys だから (2)}
--     x + sum (sort xs)
--   =   { 帰納法の仮定 }
--     x + sum xs
--   =   { sumの定義 }
--     sum (x:xs)
--   </pre>
sort :: Ord a => [a] -> [a]

-- | ソート済みのリストに新しい要素を挿入
--   
--   <pre>
--   insert x [] = [x]
--   insert x (y:ys) = if x &lt;= y then x : y : ys
--                     else y : insert x ys
--   </pre>
--   
--   <pre>
--   主張(2) ys 上の帰納法
--   
--   []の場合：
--     sum (insert x [])
--   =   { insertの定義 }
--     sum [x]
--   =   { sumの定義 }
--     x + sum []
--   
--   y:ysの場合： x &lt;= y ならば
--     sum (insert x (y:ys))
--   =   { insertの定義 }
--     sum (x:(y:ys))
--   =   { sumの定義 }
--     x + sum (y:ys)
--   
--   y:ysの場合： x &gt; y ならば
--     sum (insert x (y:ys))
--   =   { insertの定義 }
--     sum (y : insert x ys)
--   =   { sumの定義 }
--     y + sum (insert x ys)
--   =   { 帰納法の仮定 }
--     y + (x + sum ys)
--   =   { (+)の結合性 }
--     (y + x) + sum ys
--   =   { (+)の可換性 }
--     (x + y) + sum ys
--   =   { (+)の結合性 }
--     x + (y + sum ys)
--   =   { sumの定義 }
--     x + sum (y:ys)
--   </pre>
insert :: Ord a => a -> [a] -> [a]


-- | TFwH 第1章 関数プログラミングとは何か
module TFwH.Chap01

-- | テキストの型
type Text = [Char]

-- | 単語の型
type Word = [Char]

-- | commonWords n はテキストから頻出単語の出現回数の上位 n 個の単語を出現回数とともに表示するための文字列を生成する．
--   
--   <pre>
--   commonWords n = concat       -- 連結する
--                 . map showRun  -- 単語と出現回数をを表示する文字列を生成する
--                 . take n       -- 上位 n 個を取り出す
--                 . sortRuns     -- 出現回数順でソートする
--                 . countRuns    -- 出現回数を数えて単語と出現回数を対にする
--                 . sortWords    -- 単語をソートする
--                 . words        -- テキストを単語に分解
--                 . map toLower  -- テキストの文字をすべて小文字にする
--   </pre>
commonWords :: Int -> Text -> String

-- | 未定義
sortWords :: [Word] -> [Word]

-- | 未定義
countRuns :: [Word] -> [(Int, Word)]

-- | 未定義
sortRuns :: [(Int, Word)] -> [(Int, Word)]

-- | 未定義
showRun :: (Int, Word) -> String

-- | 6桁以下の数を英単語に変換する
--   
--   <pre>
--   &gt;&gt;&gt; convert 308000
--   "three hundreds and eight thousand"
--   
--   &gt;&gt;&gt; convert 369027
--   "three hundreds and sixty-nine thousand and twenty-seven"
--   
--   &gt;&gt;&gt; convert 369401
--   "three hundreds and sixty-nine thousand four hundreds and one"
--   </pre>
convert :: Int -> String

-- | 1桁の数
units :: [String]

-- | 10台の数
teens :: [String]

-- | 10の倍数
tens :: [String]

-- | 1桁の数の変換
convert1 :: Int -> String

-- | 2桁の数の桁分解
digits2 :: Int -> (Int, Int)

-- | 2桁の数の変換
convert2 :: Int -> String

-- | 2つの桁を合成
combine2 :: (Int, Int) -> String

-- | 3桁の数の変換
convert3 :: Int -> String

-- | 6桁の数の変換
convert6 :: Int -> String

-- | 接続詞
link :: Int -> String


-- | アナグラム一覧
module TFwH.Anagrams

-- | 単語の型
type Word = String

-- | ラベルの型
type Label = String

-- | anagrams n はアルファベット順の英単語リストから n 文字の単語だけを選別し,
--   同じアナグラムになる単語をまとめた結果を表示するための文字列を生成する． この文字列を表示するとn文字の単語のアナグラムの一覧となる．
--   
--   <pre>
--   anagrams n = unlines        -- 連結する
--              . map showEntry  -- エントリーを文字列に変換する
--              . groupByLabel   -- 同一ラベルのラベル付き単語をグループ化してエントリー作成する
--              . sortLabels     -- ラベル付き単語をラベルの辞書順でソートする
--              . map addLabel   -- 単語にラベルを追加する
--              . getWords n     -- n 文字の単語だけ取り出す
--   </pre>
anagrams :: Int -> [Word] -> String

-- | n 文字の単語だけを濾過
getWords :: Int -> [Word] -> [Word]

-- | 単語にラベルを追加
addLabel :: Word -> (Label, Word)

-- | ラベル付き単語をラベルの辞書順でソート
sortLabels :: [(Label, Word)] -> [(Label, Word)]

-- | 同一ラベルの付いた単語をグループ化してエントリー作成
groupByLabel :: [(Label, Word)] -> [(Label, [Word])]

-- | エントリーを文字列に変換
showEntry :: (Label, [Word]) -> String
